package frontEnd;

import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.util.ArrayList;
import java.util.List;
import javax.swing.JComponent;
import javax.swing.Timer;
import util.Location;
import util.Vector;
import backEnd.Turtle;


/**
 * TurtleView class extends JComponent. Receives information from Canvas in the form of a Turtle
 * Object. Draws Turtle and lines generated by Turtle movement.
 * 
 * @author Danny Goodman
 */
public class TurtleView extends JComponent {

    private static final int DEFAULT_HEADING = 90;
    private static final Location DEFAULT_LOCATION = new Location(0, 0);
    private static final long serialVersionUID = 1L;
    private static final int VIEW_HEIGHT = 495;
    private static final int VIEW_WIDTH = 620;
    public static final double TURTLE_HEIGHT = 30;
    private static final double TURTLE_ANGLE_1 = 40;
    private static final double TURTLE_ANGLE_2 = (180 - TURTLE_ANGLE_1) / 2;
    public static final int FRAMES_PER_SECOND = 1000;
    public static final int ONE_SECOND = 1000;
    public static final int DEFAULT_DELAY = ONE_SECOND / FRAMES_PER_SECOND;

    private Location myTurtleLocation;
    private Location myTurtleNextLocation;
    private double myTurtleHeading;
    private boolean myTurtlePenDown;
    private boolean myTurtleVisible;
    private List<Location> myTrailPoints;
    private List<Turtle> myChangesQueue;
    private Timer myTimer;

    /**
     * TurtleView Constructor. Sets size. Initializes turtle parameters.
     */
    public TurtleView () {
        setPreferredSize(new Dimension(VIEW_WIDTH, VIEW_HEIGHT));
        setFocusable(true);
        requestFocus();
        resetTurtle();
        myTimer = new Timer(DEFAULT_DELAY, new ActionListener() {
            public void actionPerformed (ActionEvent e) {
                checkQueue();
            }
        });
        myTimer.start();
    }

    /**
     * Paint the contents of the canvas.
     * 
     * Never called by you directly, instead called by Java runtime
     * when area of screen covered by this container needs to be
     * displayed (i.e., creation, uncovering, change in status)
     * 
     * @param pen - used to paint shape on the screen
     */
    @Override
    public void paintComponent (Graphics pen) {
        pen.setColor(Color.WHITE);
        pen.fillRect(0, 0, getSize().width, getSize().height);
        drawTurtle(pen);
    }

    /**
     * Adds a Turtle object to the queue to be updated from later.
     * 
     * @param changedTurtle - Turtle object containing changes in instance variables
     */
    public void addToQueue (Turtle changedTurtle) {
        myChangesQueue.add(changedTurtle);
    }

    /**
     * Updates turtle based on next turtle in the queue. Called by the timer.
     */
    public void checkQueue () {
        if (!myChangesQueue.isEmpty()) {
            updateTurtle(myChangesQueue.remove(0));
        }
    }

    /**
     * Updates the Turtle parameters based on the new Turtle information. Calls repaint().
     * 
     * @param changedTurtle - contains changes in instance variables
     */
    public void updateTurtle (Turtle changedTurtle) {
        myTurtleNextLocation = changedTurtle.getLocation();
        myTurtleHeading = changedTurtle.getHeading();
        myTurtlePenDown = changedTurtle.isPenDown();
        myTurtleVisible = changedTurtle.isVisible();
        repaint();
    }

    /**
     * Clears the trails from the List so that they are no longer painted.
     */
    public void clearTrails () {
        myTrailPoints = new ArrayList<Location>();
        repaint();
    }

    private void drawTurtle (Graphics pen) {
        if (myTurtlePenDown) {
            myTrailPoints.add(new Location(myTurtleLocation));
            myTrailPoints.add(new Location(myTurtleNextLocation));
        }
        drawTrail(pen);
        myTurtleLocation = new Location(myTurtleNextLocation);
        if (myTurtleVisible) {
            drawTriangle(pen);
        }
    }

    private void drawTrail (Graphics pen) {
        pen.setColor(Color.BLACK);
        for (int i = 0; i < myTrailPoints.size() - 1; i += 2) {
            drawLine(pen, myTrailPoints.get(i), myTrailPoints.get(i + 1));
        }
    }

    private void drawLine (Graphics pen, Location start, Location finish) {
        start = translateCoordinates(start);
        finish = translateCoordinates(finish);
        pen.drawLine((int) start.getX(), (int) start.getY(),
                     (int) finish.getX(), (int) finish.getY());
    }

    private void drawTriangle (Graphics pen) {
        Vector centerToHead = new Vector(myTurtleHeading, TURTLE_HEIGHT * 2 / 3);
        Vector headToLeft = new Vector(myTurtleHeading - (180 - (TURTLE_ANGLE_1 / 2)),
                                       TURTLE_HEIGHT / Math.sin(Math.toRadians(TURTLE_ANGLE_2)));
        Vector leftToRight =
                new Vector(myTurtleHeading + 90,
                           2 * TURTLE_HEIGHT / Math.tan(Math.toRadians(TURTLE_ANGLE_2)));
        Location vertex = new Location(myTurtleLocation.getX() + centerToHead.getXChange(),
                                       myTurtleLocation.getY() + centerToHead.getYChange());
        Location leftPoint = new Location(vertex.getX() + headToLeft.getXChange(),
                                          vertex.getY() + headToLeft.getYChange());
        Location rightPoint = new Location(leftPoint.getX() + leftToRight.getXChange(),
                                           leftPoint.getY() + leftToRight.getYChange());
        // option 1: black triangle:
        // vertex = translateCoordinates(vertex);
        // leftPoint = translateCoordinates(leftPoint);
        // rightPoint = translateCoordinates(rightPoint);
        // pen.fillPolygon(new int[] { (int) vertex.x, (int) leftPoint.x, (int) rightPoint.x },
        // new int[] { (int) vertex.y, (int) leftPoint.y, (int) rightPoint.y }, 3);
        // option 2: white triangle: shows dot for pen down
        drawLine(pen, vertex, leftPoint);
        drawLine(pen, leftPoint, rightPoint);
        drawLine(pen, rightPoint, vertex);
    }

    private Location translateCoordinates (Location point) {
        double centerX = getBounds().getWidth() / 2;
        double centerY = getBounds().getHeight() / 2;
        return new Location(centerX + point.getX(), centerY - point.getY());
    }

    private void resetTurtle () {
        myTurtleLocation = DEFAULT_LOCATION;
        myTurtleNextLocation = DEFAULT_LOCATION;
        myTurtleHeading = DEFAULT_HEADING;
        myTurtlePenDown = true;
        myTurtleVisible = true;
        myTrailPoints = new ArrayList<Location>();
        myChangesQueue = new ArrayList<Turtle>();
    }

}
